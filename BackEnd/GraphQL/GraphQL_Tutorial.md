# GraphQL Tutorial

출처 : [How to GraphQL](https://www.howtographql.com)

## 1. GraphQL이란 ?

- GraphQL은 페이스북에 의해 개발되고 오픈소스로 공유되고 있는 새로운 API의 기준이다.
- 선언적 데이터 가져오기를 할 수 있다.(enables declarative data fetching)
- 모든 쿼리에 대해 하나의 엔드포인트를 가진다.

모든 웹 서비스가 그러하듯 클라이언트는 서버에 리퀘스트를 보내고 서버는 데이터베이스에서 해당 데이터를 가져온 뒤 클라이언트에게 건내준다.
지금 까지는 RESTful API가 주도적인 API 패러다임이었지만 다음과 같은 상황 때문에 페이스북은 GraphQL을 개발했다.

### 등장배경

1. 모바일 유저가 늘어났고 이 때문에 보다 효율적인 데이터 로딩이 필요했다.
2. 프론트엔드의 프레임워크, 플랫폼이 다양해지고 이 다양함을 쉽게 대응할 필요가 있었다.
3. 신속한 기능 개발.

### GraphQL을 사용하는 회사들

- 핀터레스트
- 깃허브
- 트위터
- ...

## 2. GraphQL은 왜 REST 보다 나은가?

지난 십년동안 REST API는 API의 표준이었다. stateless 서버나 resoures로의 접근을 구조화 했다는 점에서 좋은 아이디어 였다.
그러나 REST API는 클라이언트의 급변하는 요구 사항을 따라 잡기에는 너무 융통성이 없다(매번 요청에 따라 엔드포인트를 하나 더 만들어줘야 하기 때문에!).

GraphQL은 이러한 보다 유연하고 효율적인 API의 수요에 대응하기 위해 만들어졌다. 그리고 REST API에서 겪었던 많은 비효율과 단점들을 풀어주었다.

REST와 GraphQL가 API로서 데이터를 가져올 때 어떻게 다른지 쉬운 예시를 하나 들어보자. 우리가 블로그 앱을 만든다고 하자.
앱은 특정 유저의(아마도 로그인한 유저나 어떤 유저의 계정 페이지에서) **제목이나 포스트**들을 불러와서 화면에 표시해야한다. 동시에 같은 화면에서 가장 최근 해당 유저를 **팔로우 한 유저 3명**도 불러와야 한다. GraphQL과 REST 가 어떻게 다를까?

### REST vs GraphQL : 데이터 가져오기(Data fetching)

REST API에서는 다양한 엔드포인트에서 화면에 뿌려주기위한 정보를 가져와야 할 것이다.
예를들어 먼저 `/users/:id` 라는 엔드포인트에서 유저의 정보를 가져올테고 두번째로, `/users/:id/posts`에서 유저가 쓴 포스트를 가져와야 한다.
마지막으로 `/users/:id/follwers` 라는 곳에서 유저를 팔로우하는 팔로워 리스트를 불러올 것이다.

![REST API에서 데이터를 가져오는 과정](https://imgur.com/VRyV7Jh.png)

GraphQL에서는 반대로 오로지 하나의 쿼리만을 서버에 보낸다. 서버는 요구사항을 충족하는 단하나의 JSON 오브젝트로 응답한다.

![GraphQL에서 데이터를 가져오는 과정](https://imgur.com/z9VKnHs.png)

### No more Over- and Underfetching

더 이상은 클라이언트에 정보를 뿌려주기위해 필요 이상으로 많은(Overfetching) 데이터를 불러오거나 필요에 충족하지 못하는 부분 데이터를 가져와서(Underfetching) API를 여러번 호출하지 말자. REST의 가장 큰 문제가 Overfetching 혹은 Underfetching이다. 이런 문제가 발생하는 원인은 REST가 하나의 엔드포인트에서 **고정**된 데이터 형식만 가져오기 때문이다. 때문에 클라이언트가 정확히 원하는 데이터 셋을 전달하는 API를 제공하기가 어려웠다.

### Overfetching : 불필요한 데이터까지 다운로드 해버린다.

Overfetching은 클라이언트가 그들이 필요한 것보다 더 많은 데이터를 다운로드 한다는 뜻이다. 화면에서 유저리스트를 뿌리는데 오로지 그들의 이름만 필요하다고하자. REST 에서는 `/users` 라는 엔드포인트에서 유저들의 모든 데이터를 담은 JSON 배열을 받을 것이다. 이 데이터에는 유저들의 이름 외에 많은 정보가 담겨 있을 것이다.

### Underfetching 과 n+1 문제

또 다른 문제는 Underfetching과 n+1-request 문제다. Underfetching이란 특정 엔드포인트가 필요한 모든 데이터를 제공해주지 못할 때의 문제를 일컫는다. 이 때 클라이언트는 불충분한 나머지 정보를 얻기 위해 추가적으로 다른 엔드포인트에 요청을 하게 된다.

예시로 보인 앱에서는 팔로워를 불러들이기 위해 `/users/:id/followers` 라는 엔드포인트를 추가적으로 만들어야할 것이다. 매번 앱이 화면에 유저와 팔로워를 보여줄 때마다 앱은 `/users/:id` 와 `/users/:id/follwers` 라는 두 곳에 모두 요청을 보내고 받아야 한다.

### 프론트엔드에서의 빠른 개발, UI변화가 가능

REST API에서 자주 쓰이는 패턴중에 하나는 뷰에 대응하는 엔드포인트를 만드는 겁니다. 언더페칭, 오버페칭을 해결하기 위해 그냥 뷰에서 필요한 모든 정보를 해당 뷰에 1:1대응 하는 하나의 엔드포인트에 만들어 주는 것이죠.

이러한 접근의 가장 큰 약점은 프론트엔드에서의 빠른 개선을 허용하지 않는다는 점입니다. UI가 변경될 때마다 필요한 데이터는 달라지고 결과적으로 endpoint에서 주어야할 데이터는 더 적어지거나 더 많아지므로 매번 바꾸어야 하므로 백엔드가 수정되어야만 프론트엔드에서의 수정사항이 제대로 동작합니다. 이러한 점은 생산성을 죽이고 유저의 피드백에 대한 변화를 현저하게 느리게 만들어버리죠.

GraphQL라면 해결할 수 있습니다. 자체의 유연한 성질 때문에 클라이언트 사이드에서의 변화가 생겨도 서버에서 추가적으로 API를 바꿀 필요가 없습니다. 클라이언트에서 그들이 필요한 데이터를 정확히 지정해서 얻을 수 있기 때문에 백엔드 엔지니어까지 대동해서 UI변화에 대해 업무를 할 필요가 없다는 것이죠.

### 백엔드에서 통찰력있는 분석자료를 얻을 수 있다

GraphQL은 백엔드로 들어온 요청들에 대해 잘 정제된 인사이트를 제공합니다. 각 클라이언트가 어떤 정보가 필요한지 지정해서 요청하기 때문에 사용하고 있는 데이터가 어떻게 쓰이는지 깁게 이해할 수 있습니다. 예를들어 이는 전혀 쓰이지 않은 특정 field를 버릴 수도 있고 개선할 수도 있습니다.

GraphQL은 서버로 들어온 요청들에 대해 낮은 수준에서의 퍼포먼스를 모니터링할 수 있습니다. GraphQL은 클라이언트에서 요청된 데이터를 수집하기 위해 *resolver function*이라는 개념을 씁니다. 이러한 퍼포먼스의 측정으로부터 리졸버는 우리에게 아주 중요한 인사이트를 제공합니다.

### 스키마와 타입 시스템의 장점을 얻을 수 있다.

GrapQL은 한 API의 수용성을 정의하기 위해서 강력한 타입 시스템을 사용합니다. API에 노출된 모든 타입들은 GraphQL Schema Definition Language(SDL)을 사용하여 schema로 쓰여집니다. 이러한 스키마는 클라이언트가 어떻게 데이터에 접근하는지 정의하기 위해 서버와 클라이언트 사이의 계약사항을 제공해줍니다. 그니까 일종의 명세서입니다.

한번 스키마가 정의되면 프론트엔드와 백엔드 팀은 더 소통할 필요 없이 자기 일을 할 수 있습니다. 왜냐하면 서로 네트워크를 통해 전송되는 데이터의 확실한 구조를 알고 있기 때문입니다.

프론트 엔드 팀은 필요한 데이터 구조를 모방하여 앱을 쉽게 테스트 할 수 있습니다. 서버가 준비되면 스위치를 뒤집어 클라이언트 응용 프로그램에서 실제 API의 데이터를로드 할 수 있습니다.

## 3. 핵심 개념(Core concepts)
이번 챕터에서는 우리는 그래프큐엘의 근간이되는 언어 구조를 배워볼것입니다. 여기서 타입을 정의하고 쿼리와 뮤테이션을 보내는 syntax를 보게될 것입니다. 또한 여러분이 배운 것을 실험하기 위해 사용할 수있는 `graphql-up`에 기반한 샌드 박스 환경을 준비했습니다.
### The Schema Definition Language (SDL)
그래프큐엘은 API의 스키마를 정의하기 위한 자체 타입 시스템을 가지고 있습니다. 스키마를 쓰기 위한 문법을 Schema Definition Language (SDL) 라고 부릅니다.

SDL로 `Person`이라는 간단한 타입을 정의한 예시입니다.
```
type Person {
  name: String!
  age: Int!
}
```

이 타입은 두가지 필드를 가지고 있습니다. `name`과 `age`입니다. 각 필드는 `String`, `Int` 타입을 가지며 타입 뒤의 느낌표 `!`는 이것이 필수 필드라는 것을 의미합니다.

그리고 타입간에 관계를 표현하는 것도 가능합니다. 블로깅 앱에서 보여준 예시처럼 하나의 `Person`이 `Post`에 연결될 수 있습니다.
```
type Post {
  title: String!
  author: Person!
}
```
Conversely, the other end of the relationship needs to be placed on the Person type(이 구문좀 해석해주세요 ㅠㅠㅠ)
```
type Person {
  name: String!
  age: Int!
  posts: [Post!]!
}
```
방금 우리는 `Person`과 `Post`간에 1대다관계(one-to-many-relationship)를 만들었다는 걸 알아둡시다. `Person`의 `posts`라는 필드는 실제로 `Post`의 배열로 이루어져있습니다.

### 쿼리로 데이터 가져오기(Fetching Data with Queries)
REST API로 작동을 했다면 데이터는 특정 엔드포인트에서 불러져옵니다. 각 엔드포인트는 리턴해야할 정보의 구조를 명확히 정의하고 있죠. 즉 클라이언트의 데이터 요구사항은 연결되는 URL에 효율적으로 인코딩됩니다. 

그래프큐엘에서 취하는 접근방법은 상당히 다릅니다. 고정된 데이터 구조를 리턴하는 다양한 엔드포인트를 가지는 대신에, 그래프큐엘 API는 일반적으로 단 하나의 엔드포인트만 노출시킵니다. 이것이 가능한 이유는 그래프큐엘 API가 리턴하는 데이터의 구조가 고정된 형태가 아니기 때문입니다. 클라이언트 쪽에서 어떤 데이터가 실제로 필요한지 직접 요청할수 있고, 그에 대응되게 리턴을 해준다는 점에서 그래프큐엘 API는 유연성을 가집니다.

이것은 클라이언트가 어떤 데이터가 필요한지를 *query*를 통해 표현하고 서버로 보낸다는 것을 의미합니다.

#### 기본적인 쿼리
다음의 예제 쿼리를 살펴봅시다
```
{
  allPersons{
    name
  }
}
```
쿼리 안의 `allPersons` 필드는 이 쿼리의 *root field*라고 부릅니다. 루트 필드 뒤에 따라오는 모든 것은 쿼리의 *payload*라고 부릅니다. 이 쿼리에서 지정된 쿼리의 payload는 `name` 하나뿐입니다.

이 쿼리는 데이터베이스에 저장된 모든 사람들의 리스트를 리턴합니다. 이것이 응답의 예시입니다.
```
{
  "allPersons": [
    { "name": "Johnny" },
    { "name": "Sarah" },
    { "name": "Alice" }
  ]
}
```
각 사람이 오직 `name`만 가지고 있는 것에 주목합시다. `age`는 서버에서 리턴되지 않았습니다. 왜냐하면 우리가 작성한 쿼리에서 오로지 `name` 필드만 지정했기 때문입니다.

만약 클라이언트가 `age`도 필요하다면 오로지 쿼리의 페이로드에 추가만 하면됩니다.
```
{
  allPersons{
    name
    age
  }
}
```
그래프큐엘의 가장 큰 장점중 하나는 자연스럽게 중첩된 정보를 질의(querying)할 수 있다는 겁니다. 예를 들어 `Person`이 쓴 모든 `posts`를 가져오고 싶다면 다음과 같이 작성하면됩니다.
```
{
  allPersons{
    name
    age
    posts {
      title
    }
  }
}
```
#### 매개변수(argument)가 있는 쿼리
그래프큐엘에서는 모든 필드가 0 혹은 여러개의 매개변수를 가질 수 있습니다(다만 스키마에서 지정되어 있어야합니다). 예를 들어 `allPersons` 필드는 `last` 파라미터를 가질 수 있습니다. 오로지 지정된 숫자의 사람만 가져오기 위해서 말이죠. 다음과 같이 쓸 수 있습니다.
```
{
  allPersons(last: 2){
    name
  }
}
```
### Mutation으로 데이터 쓰기
서버에서 정보를 요청할 때, 대부분의 애플리케이션은 백엔드에서 저장된 데이터를 변경할 수 있는 방법이 필요합니다. 그래프큐엘에서는 이러한 변화는 *mutations*라고 불리는 것을 사용해서 이루어집니다(즉 CRUD에서 CUD를 담당합니다). 일반적으로 다음 세개의 뮤테이션이 있습니다.
- creating new data(생성)
- updating existing data(수정)
- deleting existing data(삭제)

뮤테이션은 쿼리와 문법적으로 같은 구조가 따라오지만 항상 `mutation`이라는 키워드와 함께 시작되어야 합니다. 여기에는 `Person`을 어떻게 새로 만드는지에 대한 예시가 있습니다.
```
mutation {
  createPerson(name: "Bob", age: 36) {
    name
    age
  }
}
```
우리가 이전에 썼던 쿼리와 비슷함을 주목합시다. 뮤테이션도 루트 필드를 가지고 있고, 이 경우에서는 `createPerson`이 되겠습니다. 우리는 필드의 아귝먼트에 대한 컨셉도 알고 있습니다. 이번 경우에서는 `createPerson`필드가 새로운 `person`의 `name`과 `age`를 지정해주는 두가지 아규먼트를 받고 있습니다.

쿼리처럼 `Person`객체의 속성을 요청할 수 있는 뮤테이션의 페이로드를 지정할 수 있습니다. 이번 예시에서 우리는 `name`,`age`를 묻고있습니다.
## 4. Big Picture (Architecture)
사실 그래프큐엘은 오로지 명세(specification)만 합니다. 다시 말해 그래프큐엘 서버가 어떻게 동작해야하는지에 대한 아주 긴 문서에 불과하다는 것이죠.

### Use Cases
이번 섹션에서는 그래프큐엘 서버를 포함하는 3가지 아키텍처의 종류를 짚고 넘어가겠습니다.

1. 데이터베이스와 연결된 그래프큐엘서버
2. 다수의 서드파티 혹은 레거시 시스템 앞에 얇은 레이어로서의 그래프큐엘, 그리고 이들을 하나의 그래프큐엘 API로 통합하는 것.
3. 하나의 그래프큐엘 API로부터 연결된 데이터베이스, 서드파티, 레거시 시스템들로 접근 가능한 하이브리드 접근법

세가지 아키텍쳐 모두 그래프큐엘의 주요 사용법으로 대표되며 이것이 사용될 수 있는 컨텍스트에서의 유연성을 보여줍니다.

### 1. 데이터베이스와 연결된 그래프큐엘 서버
![GraphQL server with a connected database](https://imgur.com/cRE6oeb.png)
아마 이 사용법이 가장 흔할겁니다. 셋업 단계에서 우리는 하나의 웹서버에서 그래프큐엘의 명세를 작동시킬 겁니다. 쿼리가 그래프큐엘 서버에 도착할 때 서버는 그래프큐엘 쿼리의 페이로드를 읽고 데이터베이스에서 필요한 정보를 가져옵니다. 이것을 쿼리를 *resolving*한다고 합니다. 그 다음은 공식적으로 명세된 것을 바탕으로 응답 객체를 생성하여 클라이언트에게 리턴하죠.

그래프큐엘은 사실 전송계층과 상관없습니다(transport-layer agnostic). 
이것은 어떤 사용 가능한 네트워크 프로토콜 수도 쓸 수 있다는 것을 의미합니다.
그러니까 그래프큐엘 서버를 TCP나 웹소켓 위에서 작동시킬 수 있다는 겁니다.

그래프큐엘은 데이터베이스나 데이터베이스 저장하기 위한 형식을 쓰지 않습니다.
우리는 AWS Aurora와 같은 SQL 데이터베이스도 MongoDB와 같은 NoSQL 데이터베이스도 쓸 수 있습니다.

### 2. 기존 시스템을 통합하는 GraphQL Layer

![GraphQL layer that integrates existing systems](https://imgur.com/zQggcSX.png)

그래프큐엘의 또 다른 주요 쓰임 법은 하나의 그래프큐엘 API로 여러개의 기존 시스템을 합치는 것입니다. 이는 레거시 인프라와 수년에 걸쳐 성장해 왔으며 현재 유지 보수 부담이 큰 다양한 API를 보유한 기업에게 특히 유용합니다. 이러한 회사의 문제점은 다양한 시스템으로의 접근이 필요한 혁신적 제품개발이 거의 불가능하다는 것이죠.

그러한 점에서 그래프큐엘은 기존 시스템을 통합하는 데에 쓰일 수 있습니다. 그리고 그 복잡성을 가려주죠. 클라이언트는 그들이 필요한 데이터를 가져오기 위해 단순히 그래프큐엘과 통신하면 됩니다. 그래프큐엘 서버는 오로지 데이터베이스에서 데이터를 가져와 그래프큐엘 응답 형식에 맞게 바꿔줄 뿐이죠.

이전에 말했던 것처럼 그래프큐엘은 어떤 데이터베이스를 쓰든 관심을 두지 않습니다. 이번에도 어떤 데이터 소스, 어떻게 쿼리를 처리하는지에 대해는 관심을 두지 않습니다.

### 3. 하이브리드!
![Hybrid approach with connected database and integration of existing system](https://imgur.com/73dByTz.png)

마지막으로 위 두가지를 합치는 그래프큐엘 서버를 만들 수도 있습니다.
쿼리가 서버로 부터 받아지면 통합된 API나 서드파티, 레거시, 그리고 직접 연결된 데이터베이스를 통해 필요한 데이터를 가져올 수 있습니다.

### Resolver functions

https://imgur.com/e1gBEP5.png
하지만 우리는 도대체 어떻게 이러한 유연성을 그래프큐엘을 통해 얻을 수 있을까요? 다른 use case들에 어떻게 적합하게 만들 수 있을까요?

우리가 이전 챕터에서 배웠든 그래프큐엘 쿼리의 페이로드는 필드들로 구성되어 있습니다. 그래프큐엘 서버의 작동에서 각 필드는 resolver라 불리는 함수에 1대1 대응되고 있죠. 
리졸버 함수의 유일한 목적은 해당하는 필드의 데이터를 가져오는 것입니다.

![리졸버로 리턴](https://imgur.com/e1gBEP5.png)

서버가 쿼리를 받을 때 서버는 쿼리의 페이로드에 담긴 필드들에 맞는 모든 함수를 호출할 것입니다. 그래서 쿼리를 처리하고 각 필드에 맞는 데이터를 찾아 가져오죠. 한번 모든 리졸버가 리턴하면 서버는 이를 쿼리에서 명시한 형식에 맞게 패키징을 하고 다시 클라이언트에게 이 응답 객체를 리턴합니다.

### 그래프큐엘 클라이언트 라이브러리들
그래프큐엘은 프론트엔드 개발자들에게 특히 훌륭합니다. REST API를 통해 겪는 많은 불편과 단점들을 제거했기 때문입니다(언더, 오버페칭 같은 것들이요!). 클라이언트는 데이터를 어디서 가져오는지 신경쓸 필요 없이 오로지 하나의 API만 쓰면 됩니다.

순수히 선언적 접근방법으로 데이터를 가져오기 보다 그래프큐엘을 쓰면 어떠한 큰 변화가 있는지 살펴봅시다. REST API에서 데이터를 가져올 때 대부분의 애플리케이션은 다음 단계를 수행해야합니다.

1. http request를 생성하고 보냅니다(자바스크립트에선 `fetch`가 있겠죠).
2. 서버의 응답을 받고 파싱합니다.
3. 데이터를 로컬에서 가지고 있습니다(클라이언트의 컨텍스트에서).
4. 데이터를 UI에 보여줍니다.

선언적 데이터 가져오기 접근방법에서는 클라이언트는 오로지 다음 두개만 하면됩니다.

1. 필요한 데이터를 명시합니다.
2. 데이터를 UI에 보여줍니다.

데이터 저장뿐만 아니라 모든 하위 수준의 네트워킹 작업은 추상화되어야하며 데이터 종속성 선언이 지배적인 부분이어야합니다.

이것이 바로 Relay 또는 Apollo와 같은 GraphQL 클라이언트 라이브러리가 가능하게하는 것입니다. 이들은 반복적 인 인프라 구현을 다루지 않고 애플리케이션의 중요한 부분에 집중할 수 있어야하는 추상화를 제공합니다.


## 5. Clients

## 6. 기타등등