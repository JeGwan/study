이곳에서는 [elastic](https://www.elastic.co/kr)에서 안내하는 **Elasticsearch 시작하기** 내용을 정리합니다.

개인 공부 기록용이지만 도움이 되셨으면 좋겠습니다.

## Elastic Stack?
엘라스틱 스택이란 키바나, 엘라스틱서치, 로그스태쉬 와 같은 프로그램을 함께 일컫는 용어인거 같다. 혹은 이것으로 이루어진 구조를 부르는 듯. 모두 오픈소스 프로젝트이다.

그 외에 추가 적인 기능들은 x-pack이라는 추가제품들로 지원받을 수 있다.
엘라스틱 클라우드는 한달에 45불로 이용하는 클라우드 서비스이다.

여기까진 그냥 광곤데???

여튼...

## Elasticsearch

엘라스틱 스택의 심장이라 불릴정도로 중요한 역할을 한다.

스케일아웃이 가능한 환경 개발자들이 사용하기 편한 API를 지원
풀텍스트 검색지원. 애그리게이션? 을 통해 집계도 가능.
데이터베이스 엔진으로 각광받고 있다.
아파치 2 라이선스 오픈소스이다.
아파치 루신이라고 하는 검색엔진 라이브러리를 사용한다.

### Apache Lucene
자바로 만들어진 검색라이브러리. 대표적으로 아파치 솔라와 엘라스틱 서치가 있다.

엘라스틱은 기본적으로 **클러스터**를 이용한다..?
엘라스틱서치는 데이터를 Shard단위로 분리해서 저장하는데
샤드란 루신레벨의 검색 스레드이고 엘라스틱서치가 실행된 한 프로세스를 **노드**라고 부른다.

노드를 여러개 실행시키면 한 클러스트로 묶여서 같이 동작한다.
노드가 여러개 생성되면 데이터가 저장된 샤드들이 각노드에 샤드로 분배되어 저장된다.
샤드는 무결성을 위해 리플리카라는 복제본을 만들어 또 저장을 한다
프라이머리 샤드와 리플리카는 같은 내용의 도큐먼트들을 저장한다.
유실된 노드가 생기면 유실된 샤드들을 프라이머리 샤드가 다시금 복제 한다.

검색과정: 클라이언트 검색요청을 받으면
검색명령을 받은 노드가 각각 샤드로 전달을 하게 되고
샤드에서는 클라이언트가보낸 쿼리에 맞는 해당 도큐먼트를 찾아서 리턴한다.

어떤 노드가 검색요청을 받아도
마지막 리턴은 샤드레벨로 도큐먼트를 리턴해준다. 머 여튼 같은 결과를 리턴한다.

엘라스틱은 도큐먼트 기반 검색엔진이다. 기본적으로 JSON 도큐먼트를 사용한다.
레스트API 를 제공한다.

호스트:포트/인덱스/타입/도큐먼트아이디

풀텍스트 검색엔진
텍스트 문서들을 검색에 가능하게 가공을해서 역인덱싱을 한다.
검색에 있어서 대소문자 구분이라던지 원어로 검색하는 기능 등을 가지고 있음.

실시간 검색엔진이라 데이터가 저장될 때마다 저장됨과 동시에 색인구조를 만들기 때문에
실시간으로 검색이나 쿼리가 가능하다. 이건 모두가 그렇지 않나?

검색과 어그리게이션을 지원하기때문에 분석/집계가 가능하다.
통계를 낸다던지 그룹단위로 별도의 통계를 본다던지 집계가 가능하다.

자바를 사용하고 자바 힙메모리를 JVMoption파일에서 설정할 수 있다.

여러개의 노드를 실행시킬 수 있으며 이는 루트 폴더를 복제해서 bin/elasticsearch
하면된다.
`nano config/elasticsearch.yml`로 클러스트 이름과 노드이름을 수정할 수 있고
`bin/elasticsearch -E cluster.name=myCluster -E node.name=myNode`로 컨피그 파일을 수정하지 않아도 실행할 때 클러스트와 노드를 설정해줄 수 있다.
이를 통해 같은 클러스트 네임을 가지면 미리 실행되는 마스터 노드를 찾아 바인딩이 되고 두번째 엘라스틱서치 서버는 9201번포트에서 실행된다.

그리고 데이터를 입력하고

```bash
curl -X PUT "localhost:9200/twitter/_doc/1" -H 'Content-Type: application/json' -d'
{
    "user" : "kimchy",
    "post_date" : "2009-11-15T14:12:12",
    "message" : "trying out Elasticsearch"
}
'
```
localhost:9200/twitter/_doc/1에 접속하면 저장된 내용을 볼 수 있다.
9201에가도 마찬가지다 클러스터네임이 같아 바인딩되어있기 때문이다.

키바나를 받아 압축을 풀고 bin/kibana를 하면 5601번 포트에서
키바나로 무언가 할 수 있다.. 백오피스 마냥...

새로운 인덱스를 생성할 때
세팅을 따로 지정할 수 있다. 매핑이라던가 샤드수라던가
인덱스를 만들면서 세팅을 해야 적용된다.

검색은 `indexName/_search` 엔드포인트에서 검색할 수 있다.
매핑 정보는 `indexName/_mapping` 에서 확인할 수 있다. 이거는 일종의 데이터구조를 보여준다.

### 조건별 검색
본격적으로 검색을 해보자
```
GET indexName/_search
{
  "query":{
    "match":{
      "title":"fox"
    }
  }
}
```
이런식으로 써주면 타이틀에 fox가 있는 데이터만 가져오게 된다.
타이틀에 여러 키워드를 띄어쓰기로 넣으면 OR 조건이 된다.
`"title":"fox dog"` 이렇게 넣으면 fox나 dog를 포함한 결과가 나온다.

근데 "fox dog"라는 문자열로 찾을려면 match 가 아닌 `match_phrase`를 써야한다.
그리고 해당 데이터의 결과는 스코어 별로 정렬되어 나온다.
이런 스코어 점수를 계산하는 것을 영어로는 Relevance라고 하는데 우리말로 관련성정도가 되겠다.

점수는
1. Term frequency :
 해당 키워드가 몇번이 나왔는가.
2. Invert document frequency
 전체 문서에 대해서 해당 키워드가 몇번 나왔는가.

이런 알고리즘을 따르는데 자세히 보기는 
[Sorting and relavance](https://www.elastic.co/guide/en/elasticsearch/guide/master/sorting.html)
를 참고하자.(넘기다 보면 나옴!)

### 다중조건 검색
여러가지 조건을 넣을땐 bool 쿼리를 쓰는데 bool 안에는 must, should, not을 쓸수 있다.
```
{
  "query":{
    "bool":{
      "must":[
        {
          "match":{
            "title":"quick"
          }
        },{
          "match_phrase":{
            "title":{
              "query":"lazy dog"
            }
          }
        }
      ]
    }
  }
}
```

먼저 `must`는 AND조건으로 머스트 안에 들어간 조건이 모두 and 로 결합된다.

`must_not`은 그것을 포함하지 않는 것만 찾는다.

`should`는 반드시 매칭될 필요는 없지만 매칭될 시 더 높은 점수를 부여할 수 있고, 특별히 검색조건별 점수를 줄수 있다.
쿼리 밑에 `boost`값을 써넣어줌으로써 더 높은 점수를 줄 수 있는데, 기본 점수는 1이다.

`should` 와 `must`를 혼용할 수도 있다. 여튼간 boost 밑에 쓰고싶은 데로 넣으면 된당..

### Highlight
쿼리레벨과 같게 하이라이트 키를 추가해서 특정 필드를 하이라이팅 할 수 있다.
어떻게 해주냐고? HTML 태그로 껴서 해준다 `<em></em>`안에 넣어서!

### Filter
그냥 쿼리와 달리 필터는 캐싱을 해서 찾기 때매 더 빠르다. 근데 아무거나 되는게 아니다.
어떤게 되는지는 강의 해주는 사람이 말안하고 넘어갔다.. 하아 답답해 너무 강의가 기본 개념없이 되는거만 훅훅 훑고 가는 기분이다 ㅠㅠ
그리고 강의 해주는 분이 너무 대충 설명하고 넘어간다.. 거의 읽는다...
보다가 느낀건데 필터만 하면 스코어를 주지 않는다. 그 스코어를 계산하는 알고리즘이 없기 때문에 더 빠른게 아닌가 생각이 든다.

### Analysis
`indexName/_analyze`로 쿼리를 보내면 텍스트에 대해 검색가능한 값들로 바꿔준다.
`tokenizer` 로 어떻게 토큰화 시킬건지 정할 수 있다.(standard,letter...)
`text` 키에 바꿀 텍스트를 넣는다.
`filter` 키를 하면 바꿀 텍스트에 무언가 처리를 할 수 있다. 예를들어
1. lowercase : 소문자로 바꿔준다.
2. unique : 중복된 값을 제거해준다.

토크나이저에 standard를 하면 특수문자와 공백을 구분자로 여긴다.
토크나이저에 letter를 하면 문자를 제외한 모든 것을 구분자로 여긴다.
레터 토크나이저를 하면 quick.sdof_sadf 등을 넣으면 quic, sdof, sadf  세텀으로 추출하게 된다.
토크나이저에 uax_url_email을 하게되면 email, url 등을 묶어서 텀으로 추출해준다. 그 텀의 타입도 email, url로 지정해준다.

### Aggregation
query와 같은 레벨, 
이건 한마디로 count(*) 같은 거다. 집계해준다. 특정 필드를 지정하면 해당 필드의 카운터를 group by 로 집계해준다.
query 와 같이 쓰면 해당 쿼리 조건에 맞는거만 힛츠와 에그로 결과를 나타내준다. size를 쿼리와 같은 레벨로 하고 0으로 해주면
히츠는 안나오고 에그만 나온다.

#### sub_agg
에그리게이션 밑에 특정 조건에 대해 또 에그리게이션을 시킬수 있다. 예를들어 특정 컬러로 집계를 하고, 그 컬러 그룹의 어떤 컬럼에 대한 평균값을 산출하라고 할 수도 있다.

### Update
`GET /indexName/docName/id`로 해당 데이터를 읽기 했다면
`POST /indexName/docName/id`는 해당 데이터를 수정한다.
그리고 수정할 때마다 버전이 달라진다. 트랜잭션이 없기 때문에 버전을 되돌릴수는 없다.
엘라스틱서치는 부분업데이트 따위없다. 그냥 업데이트도 딜리트 인서트 과정을 거쳐 업데이트 되는거처럼 보일 뿐이다.

### Mapping
`GET /indexName/_mapping`에서 인덱스 내의 매핑 정보를 볼 수 있다. 타입도 알아서 정의한다.
