## 1강. 강의소개 및 극댓값찾기
Peak finding : 극대값 찾기

### 1차원 경우
숫자 배열이 있다고 생각합시다.

a|b|c|d|e|f|g|h|i
-|-|-|-|-|-|-|-|-
1|2|3|4|5|6|7|8|9

a-i는 배열의 각자리에 들어간 숫자를 나타내고.  
1-9는 배열의 인덱스입니다.

만약 B의 자리가 극대값이라면 `b>=a and b>=c` 가 성립합니다.

즉 극대값이란 것은 지역적인 특성입니다.
1차원에서는 간단합니다. 오른족과 왼쪽을 보고 양쪽 요소의 값보다 크거나 같으면 극대값이 됩니다.
가장자리의 같은 경우 `i>=h`면 극대값이 됩니다.

이번 강의의 문제는 **만약 있다면 극댓값을 찾기** 입니다.

### Algorithm 1 : straightforward algorithm
straightforward algorithm : 왼쪽부터 시작해서 오른족으로 걸어가는 알고리즘 입니다.
```
        ----
    ----    ----
----            ----
```
위의 경우에는 중간어딘가에 극대값이 있고 증가하다가 감소하는 경우입니다.
이럴경우 총 `n/2`개의 원소를 보면 됩니다.

최악의 경우, 우리는 `n`개의 요소를 모두봐야합니다. 이런 최악의 경우의 복잡도를 `Big-O Notation`으로 `O(?)`식으로 표현합니다. 괄호안의 자리에는 `n`개의 인풋을 받았을 때 알고리즘을 시행해야하는 횟수를 적어줍니다. 위의 알고리즘과 같을 때 우리는 최대 O(n)개의 연산을 수행하게 됩니다.

### Algorithm 2 : Divide & Conquer algorithm
어떻게 하면 연산을 줄일 수 있을까요? 극대값은 여러개가 있을 수 있고 오로지 하나만 찾으면 됩니다. 이런 예시가 적합하겠군요. 가운데 숫자로부터 양쪽 수를 비교한뒤 더 큰수가 있는 쪽 절반을 잘라 다시 가운데값을 취하고 양쪽을 비교합니다. 이런식으로 1/2씩 잘라서 검색하다보면 극댓값 하나를 찾을 수 있습니다. 
이런 접근 방법이 **분할정복법(Divide & Conquer)** 입니다. 

먼저 `n/2`를 봅니다. 그리고 양쪽을 차례대로 봅니다. 
```js
if(a[n/2] < a[n/2 - 1]){
  // 이 경우 왼쪽 절반에 극대값이 있습니다.
}else if(a[n/2] < a[n/2 + 1]){
  // 이 경우 오른쪽 절반에 극대값이 있습니다.
}else{
  // 이러면 이미 극대값을 찾은겁니다. a[n/2]가 양쪽과 같거나 양쪽보다 더 큰 경우이니까요!
}
```

시간복잡도를 생각해봅시다.
```js
// theta(1)은 양쪽을 차례대로 보는 연산행위를 의미합니다. 차례대로 보기때문에 최대 2번이 걸리는데, 인풋 값인 n과는 비례관계가 없이 상수적으로 2번연산하기 때문에 theta(1)이라 칭한겁니다.
// T(n)은 n개의 인풋이 들어올 때 걸리는 시간 복잡도를 의미합니다.
T(n) = T(n/2) + theta(1);
// n개의 경우 처음 중간자리에서 양쪽을 둘러보는 연산 + 그리고 결정된 절반에서 걸리는 연산
T(1) = theta(1);
// 1개의 경우 바로 리턴
T(2) = theta(1);
// 2개의 경우 둘중 하나를 잡고 나머지 하나를 비교하면 바로 결정되므로
T(3) = theta(1);
// 3개의 경우 역시 가운데에서 양쪽을 보면 바로 결정되므로
T(4) = T(2) + theta(1);
// 4개의 경우 2개씩 잘라 양쪽을 보고 결정한다음 결정된 영역으로 이동해서 또 봐야하므로.
```
규칙성이 보이나요? 분할 정복법은 절반씩 잘라서 보므로 인풋이 `n`개 일때 절반씩 쪼개다 보면 **log<sub>2</sub>n**개를 보게 됩니다. 이게 얼마나 연산을 줄어주냐면요. 1024개의 인풋이 들어오는 경우 Straight forward 방법으로는 1024개의 연산을 수행해야하지만 분할 정복법의 경우 **log<sub>2</sub>1024 = 10** 10번만 연산을 하면 됩니다. 어마어마하죠?

### 2차원의 경우
2차원의 경우 m개의 행과 n개의 열로 이루어진 행렬을 생각합시다.
1|2|3
-|-|-
.|c|.
b|a|d
.|e|.

위의 예시 2차원 행렬에서 a가 극대값이 될려면
```js
a>=b && a>=c && a>=d && a>=e
```
네가지를 만족해야합니다.

이번엔 다른 알고리즘으로 풀어보죠.

### Algorithm 3 : Greedy Ascent algorithm
시작점과 방향을 정하고 그 방향을 따라 극대값을 찾는방법입니다.
다음과 같은 4x4 행렬이 있다고 칩시다.
1|2|3|4
-|-|-|-
.|.|.|.
14|13|12|.
15|9|11|17
16|17|19|20
예를 들어 시작점을 12에서 시작하고 왼쪽으로 가는 것을 시작이라 합시다. 만약 왼쪽이 12보다 작으면 반대방향으로 갑니다. 

이런식으로 가면 최악의 경우 탐욕상승알고리즘(Greedy Ascent의 번역어입니다)은 최대 **O(nm)** 의 복잡도를 가집니다. 만약 n=m인 즉 Square Matrix라면 **O(n<sup>2</sup>)** 가 됩니다.

### Algorithm 2 : Divide & Conquer algorithm 2D Version 1
이번엔 분할정복법을 2차원에서 적용해봅시다.

1. 먼저 `j=m/2`인 가운데 열 `j`를 구합니다.
2. `j`열에서 1차원 분할정복법으로 극대값을 찾습니다. 극대값의 인덱스를 (i,j)라고합시다.
3. 열에서는 극대값이 되었으므로 이번엔 행에서도 극대값을 찾습니다. `i`행에서 극대값을 찾습니다.

여기엔 크리티컬한 문제가 있습니다. `i`행에서는 극대값이 없을수도 있거든요.
다른 알고리즘이 필요합니다.

### Algorithm 4 : Divide & Conquer algorithm 2D Version 2

1. 먼저 `j=m/2`인 가운데 열 `j`를 구합니다.
2. `j`열에서 열의 최대값 (i,j)를 찾습니다.
3. (i,j-1) , (i,j), (i,j+1) 를 비교합니다. (여기서 극대값이 될수도 있고 아닐수도 있습니다)
4. (3번에서 안된다면) 해당 행에서 (i,j)보다 왼쪽의 값(i,j-1)이 더 크면 왼쪽 열을 새롭게 잡고 다시 1번부터 반복합니다. 오른쪽 값이 더 크면 오른쪽 열을 새롭게 잡고 똑같이 합니다.

```js
T(n,m) = T(n,m/2) + theta(n);
```
여기서 theta는 열이 정해지면 글로벌 맥시멈을 찾는 연산이 최대 n번 수행되기 때문이다. 
```js
T(n,1) = theta(n);
```
여기서는 반으로 자르고 잘라서 마지막 한 행이 남을 때 종료조건이 되므로 위의 식이 마지막 식이다.
```js
T(n,m) = thata(n)+ ... + theta(n);
```
따라서 점화식은 1차원과 비슷하게 theta(n)이 밑이 log<sub>2</sub>m번 만큼 있다.
즉 **O(nlog<sub>2</sub>m)** 의 복잡도를 가진다.
그리고 이 알고리즘은 찾을 수 있다.