### TEST

unit test > 로직이 순수하게 잘 도는가.
integration > 개발 환경 혹은 실제 배포 환경에서 DB까지 오고, 리턴값이 갈때까지 총 테스트
end to end test (E2E) -> 실제 환경에서 돌려 보는 것.

테스트케이스를 만들어 자동화시키자!
### TDD : 테스트 주도 개발이란?
설계&기획 후 바로 테스트케이스를 다 만든다! 그 뒤 개발에 들어감.
통과하면? 다른 기능을 위한 추가 테스트 케이스도 만들고 해당하는 것을 통과하는지 확인함.
그다음은 리팩토링함.(클린 코드!)
그다음 다시 테스트 함.
통과하면 배포.

ex:
새로만드는 경우
1. 요구사항인지
2. A 기능 테스트 케이스 작성
3. A 기능 개발
4. A 기능 태스트 케이스 pass 확인
5. B 기능 테스트 케이스 작성
6. B 기능 개발
7. B 기능 테스트 케이스 pass 확인
8. 리팩토링
9. A,B 기능 테스트 케이스 pass 확인
10. 배포

기존 앱에 추가하는 경우
1. 요구사항인지
2. 기존 기능 테스트 케이스 존재 확인
3. 신규 기능 테스트 케이스 추가 작성
4. 신규 기능 개발
5. 기존, 신규 테스트 케이스 pass 확인
6. 리팩토링
7. 기존, 신규 테스트 케이스 pass 확인
8. 배포

기능 개발 이후 테스트 케이스를 작성하면
해당 기능이 테스트를 커버하는 범위가 좁게 됨... 사람이다보니 만들어 놓은거에 국한해서 생각함

테스트 케이스를 먼저 만들면 더 좋음...

git commit 할 때 eslint에 안걸려야 커밋되게 
git push 할 때 해당 기능에 대한 test case가 없으면 안되게 유도하는 개발문화가 있다.

### SW 개발 프로세스
프로젝트 매니저, 마일스톤등... 익숙한 PM 툴

**Waterfall**
1. 요구사항 정의 -> 2. 설계(숲,구조,인터페이스) -> 3. 개발 -> 4. 확인 -> 5. 유지보수
V-Model (waterfall 기반) -> 다른 공학 설계, 구현에서도 많이 쓰임

Waterfall 개발 방식의 단점..
1. 프로젝트 초기에 구체적인 요구사항 도출이 어렵다.
2. 프로젝트 중간에 발생하는 요구사항 변경 반영이 어렵다.
3. 프로젝트 과정 중 과도한 중간 산출물 요구.

**AGILE**
더 나은 소프트웨어 개발을 위한 캠페인?
결과물을 마지막에 한꺼번에 주지말자, 고객이 처음부터 쓸수 있게 러프하게 주고 점점 완성시켜주자.
개발원칙 12가지
1. SW개발의 최우선 목표는 빠르고 지속적으로 가치있는 제품을 고객에게 전달하는 것
2. AGILE 프로세스는 고객을 위해서라면 비록 개발 후반일지라도 요구사항의 변경을 적극적으로 환영하고 반영하자.
3. 동작하는 SW를 짧은 간격으로 자주 전달하자.
4. 요구사항을 내는 고객과 개발자는 프로젝트 내에서 긴밀하게 협력해야한다.
5. 동기가 부여된 개인들 중심으로 프로젝트를 구성한다. 개발팀에 필요한 환경과 지원을 제공, 일을 잘 끝낼수있도록 개인과 팀을 신뢰하자
6. 개발팀 내부에서 정보를 전하는 가장 효율적인 방법은 서로가 얼굴을 마주 보면서 대화하는 것이다.
7. 동작되는 SW는 진척의 주된 척도
8. AGILE 프로세스는 지속 가능한 개발을 장려하고 개발자 사용자는 일정한 개발 속도를 유지해야한다.
9. 기술적 탁월성과 좋은 설계에 갖는 지속적 관심이 민첩성을 높인다... Agile a.기민한
10. 간단하게 간다. 하게 될지 모르는 일을 미리 설계하지 않는다.

**Agile Scrum**
Todo 관리하는 거나 다름없다.
1. 프로덕트 백로그(일감, 큰 chunk 단위의 요구사항) 
2. 스프린트 플래닝 : 2주동안 할 수 있는 일감을 떼온다.
3. 그 일감을 스프린트 백로그에 쌓는다.
4. 스프린트 : 분석, 설계, 빌드, 테스트, 리뷰 등을 한다. (데일리 미팅 포함)
5. 배포가능한 프로덕트가 나온다.

스프린트의 사이즈에 따라 난이도를 피보나치 수로 정한다.
1,2,3,5,8,13 이런식으로 보수적으로 난이도를 잡기 위해.
이 난이도를 설정하기 위해선??
각자가 생각하는 어려움의 정도를 피보나치 번호가 적힌 카드를 내놓는다.
목소리 큰사람의 입김에 영향을 받지 않게 하기 위해.

스토리 : 유저가 ~~ 할수 있어야한다 
=> 이걸 여러 태스크로 나눈다.
=> todo, inprogress, done의 status로 나눈다.

이후 스프린트 리뷰를 한다.
프로덕트 오너나 고객에게 보여주기도 한다.
스프린트 번다운 => 스토리 포인트를 난이도 합으로 시작해서 마지막까지 0에 수렴하게 그래프를 그린다.

스프린트 레트로스펙티브
잘된거, 개선될수 있는거, 해결할 수 있는 방법
1주면 1주 2주면 2주 스프린트 기간을 꼭 통일해라.

칸반?
투두, 두잉, 던. 투두가 지속적으로 업데이트 된다.

### 배포(deployment)에 대해
웹서버 : 퍼블릭하게 접속
로컬호스트 : 오직나만 접속
깃을 거쳐서 버전관리를 하고 배포한다.
라이브되고 있는 것을 수정한 코드로 즉시 수정하는 것은
하늘을 날고 있는 항공기에 이것저것 테스트한다고 날개든 뭐든 건드리는거랑 같다.

배포란? 내 컴퓨터에서 돌아가는 코드를 다른 컴퓨터에서도 돌아가게

개발환경에서 우리는
런타임 환경을 알고 있다.
디펜던시가 뭔지 버전이 몇인지 알고 있다.
포트 번호를 알고 있다.
OS가 먼지 알고 있다.
파일 패스를 알고 있다.
비밀스런 정보들도 알고 있다.

다른 컴퓨터에선 모두 모른다.

도커라는 툴을 이용해서 환경을 직접 만든다..?

Tips.
꼭 상대주소로 써라.
환경변수에서의 포트를 가져오고 없으면 개발환경에 맞는 포트를 가져온다.
의존 라이브러리를 기록해놓고 다른 컴퓨터에서도 설치하자.
scp 커맨드를 이용하여 API등을 옮겨 놓자.

### 배포 환경
개발환경 : 각자작업하는 컴터
DEV환경 : 통합해서 돌려보는 개발 서버
Staging환경 : 실제 서비스 환경과 같은 환경
Production : 실제 서비스

### CI & CD
feature A~F 까지만들었다치고 테스트도 괜찮았는데
feature G 를 추가할 때

CI??
Continuous Integration 지속적인 통합 테스트.
소스 레파지토리에 pull request를 하면서 마스터에 머지 되기 전에
지금까지 만들어 놓은 모든 테스트 케이스에 대하여 빌드해보고 테스트를 돌리고 결과를 받는다.
그 테스트를 풀 리퀘나 푸쉬에 걸수있다(즉 그작업을 할려고할대 자동으로 실행되게) 

CD??
개발완료 > ssh로 접속 > 경로 변경 > 깃을 사용하여 pull 받음 > build > 환경변수를 고려하여 서버 리스타트 > 서버 헬스 체크 > end
무지 귀찮고 힘듦... 손으로는 배포하기 싫어짐..
Continuous Delivery
배포 자동화??
개발 > 소스 레파지토리 > CI서버에서 테스트 > 테스트 > 스태이징 > 프로덕션1

CI 툴?
Circle CI travis CI
CD 툴?
젠킨스, 서클

DevOps 포지션???

### 코드 리뷰
풀리퀘 > 코드리뷰 > 코드 업데이트  > merge
코드리뷰의 장점
1. 부작용, 버그의 조기 발견
2. 중복 코드 방지, 재사용성 증가
3. 코드 & 플로우 컨벤션 통일
4. 팀원들 모두의 프로젝트 코드에 대한 이해도 증가
5. 리뷰가 있을 것이라는 긍정적 부담
6. 팀 전체의 기술적 성장
7. 작성자를 추궁하지 않는 문화 구축


### 질문하기
1. 검색, 관찰을 통해서 질문의 키워드나 표현을 개선하자.
2. 제목이 좋아야한다. 그래서 내용을 적고 제목을 내용의 요약하는 형태로 해보자.
3. 바쁜 동료에게 물어본다고 생각하고 질문하자
4. 본격적인 질문 전에 배경 설명
5. 시도와 시도의 결과를 첨부하자
6. 내가 겪고 있는 문제를 재현할 수 있게 웹상의 코드러너를 첨부해주자.
7. 가독성을 위해 코드 스니펫을 활용... > 그니까 색상 있고, 인덴트 있고... 

### 글쓰기
TIL 과 블로깅?
TIL(Today I Learned) : 일기!
블로그 : 발표!
가장 빨리 배우는 방법은?
누군가를 돕거나 가르치는 것.

GatsbyJS, Netlify