# 알고리즘에 관하여
**알고리즘** 공부를 할 시점이 왔다 제기랄.

## 1. Linked list
자료를 저장하는 구조 중 하나
일렬로 연결된 데이터를 저장할 때 사용
하나의 노드에 값과 다음 데이터의 주소를 가지고 있음

**배열과 다른점은?**
배열은 방들이 물리적으로 한곳에 모여 있어, 크기를 정하면 늘리거나 줄일 수 없음. 링크드리스트는 다음놈 주소를 가지면서 데이터를 추가하거나 삭제할 수 있음.

링크드 리스트는 데이터를 삽입하고 싶으면 앞의 노드가 가지고 있던 주소를 자기가 갖고 앞의 노드에게 자기의 주소를 알려줌.
빼고싶으면 다음 데이터의 주소를 앞 노드에게 주면 됨.
자바에서는 이렇게 뺀놈들의 메모리를 알아서 정리해주는데(Garbage Collector! 한가할 때(idle time)나 메모리를 더 달라고 요청할 때 가비지 컬렉터가 실행된다!) C에선 직접 필요없다고 뭔가 해줘야 된다.
한마디로 내 뒤에 누구 있는지 잡고 있으믄서 값도 있는 놈이라 생각.
링크드 리스트는 주소를 찾으러가기 때문에 속도가 조금 느릴 수 있음.
근데 배열에 비해 계속 붙일 수 있으니까 편해. 편한만큼 느린거 뿐이얌.

### 1.1 단방향 & 양방향
단방향 -> 다음놈의 주소만 가지고 있기 때문에 검색할 때 앞부터 순차적으로 검색해야함.
양방향 -> 내 앞의 놈의 주소도 가지고 있음. 근데 이것도 뒤에서부터 검색할 수 있는 거 뿐 순차적인건 마찬가지자너? 근데 끝에 삽입할 때는 단방향보다 훨씬 빠르징. **단방향은 앞부터 계속 가서 마지막놈 나올 때 삽입하니까**

### 1.2 정렬방법?
O(N)따위가 모에여???
space와 time을 얼마나 먹는지 알아야함

## Dynamic programming (동적계획법)
동적 계획법. 그냥 쉽게 말해서 앞에서 구한 답을 뒤에서도 이용해서 조금 더 연산이 덜 걸리게 하는 효율적인 방식.
이광근 교수의 저서 **"컴퓨터 과학이 여는 세계"**에서는 다이나믹 프로그래밍을 본질적인 의미를 더 살려서 **기억하며 풀기**로 더욱 적절하게 번역하였다.

## Divide and Conquer (분할정복법)
분할 정복법은 재귀적으로 자신을 호출하면서 그 연산의 단위를 조금씩 줄어가는 방식이다. 예를 들어
function F(x):
  if F(x)가 간단 then:
    return F(x)를 계산한 값
  else:
    x 를 x1, x2로 분할
    F(x1)과 F(x2)를 호출
    return F(x1), F(x2)로 F(x)를 구한 값
이런 방식~

## O(n) 이게 뭔 뜻?

## 스택이란?

## Buffer overflow(스택 오버 플로우)
프로그램이 실행될 때 입력받는 값이 버퍼 메모리를 넘쳐버리는 현상. 준비된 메모리보다 여튼간 많이 쓸때 버퍼 오버플로우라 칭한다.

## Quick sort
